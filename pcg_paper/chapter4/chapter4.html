<h1>4  House Floorplan Generation</h1>
<p>To date, procedural methods for creating buildings have produced buildings that are merely textured facades, containing no internal structure. Also, most algorithms do not draw upon insights from architecture. We introduce a method for procedurally generating a single-family residential unit, a house, automatically. The first step in generating the house uses a grammar which constructs a graph of the rooms and connections between rooms. The rules of the grammar are based on insights gleaned from particular architectural styles. Consequently, the algorithm is capable of producing houses in the style from which the rules are drawn. During the second step, rooms reach their appropriate sizes using Monte Carlo semi-deformable growth.</p>

<p>Our method of building generation is fundamentally different from methods previously discussed. While most methods generate only exteriors of buildings with no interior structure or layout, our method focuses on the floorplan with the assumption that the floorplan will eventually dictate most of the exterior appearance. Most other methods focus primarily on commercial buildings–office buildings, skyscrapers, and other large, fairly regular buildings. In exploring the problem of procedurally generated buildings, we found residential buildings to be highly complex due to their variety and irregularity and chose them as the target for our new method.</p>

<h2>4.1 Algorithm Principles</h2>

<p>Two insights from Christopher Alexander's architectural writings provided foundations for our work [Alexander et al. 1977]. First, Alexander points out that architectural patterns vary between cultures and a particular set of rules will not be able to produce houses of all different cultures. Thus, we chose to focus on American-style residences. Second, Alexander’s description of the layout of residential units revealed a crucial distinction between two types of rooms: some rooms are designated private, intended to be used by only one individual or couple; other rooms are designated public, intended to be used by a group. This simple distinction formed the basis of our graph generation step. Additional architectural insight came from browsing hundreds of house plans. These plans enabled us to make broad statements about average American houses that guided the development of the algorithm’s ruleset which is based on commonalities among houses.</p>

<p>To ensure that the floor-plans generated by our technique are realistic, our method uses statistics and rules from common American homes such as the probability that a room will connect to another room, etc. These statistics and rules were gathered by analyzing many house plans by hand. The rulesets and the statistics are stored in text files in a human-readable format. A user could potentially rewrite the rules and statistics to apply this method to buildings of other cultures.</p>

<p>We also observed the following characteristics of floor plans and utilize them to provide constraints for the algorithm:</p>

<p><em>Room Size.</em> Although the size of rooms varies depending on the size of the house, we observed that within any particular house the room sizes relative to one another are somewhat fixed according to the type of room. For example, a bedroom is usually larger than a bathroom, and a kitchen is usually larger than a pantry. We used this observation to define relative room sizes based on the type of room.</p>

<p><em>Footprint Size.</em> The footprint determines the exterior boundaries of the house. The larger the footprint, the more rooms the house can contain. We vary the size of the footprint to allow the algorithm to generate different size houses.</p>

<p><em>Public to Private Square Footage Ratio.</em> In larger houses, we observed that private and public ratios begin to favor more square footage for public spaces. The increase in square footage is largely accounted for by public space. Conversely, in smaller houses the ratio of public to private space is closer to 1:1. We chose a ratio of public to private space of 3:2 that represents "average-sized" houses.</p>

<p><em>Room Aspect Ratio.</em> We observed that rooms within houses rarely exceeded an aspect ratio of 2:1. Thus we constrain rooms to not exceed that ratio.</p>

<p>
  The procedure for generating residential units has two distinct steps:
  <ul>
    <li>Graph generation</li>
    <li>Room expansion</li>
  </ul>
</p>

<h2>4.2  Graph Generation</h2>

<p>We represent the basic structure of a house as a graph with each node corresponding to a room and each edge corresponding to a connection between rooms. In the first step of the procedure, a graph encoding of rooms is generated. The graph generation phase itself occurs in four steps ***FIGURE***.</p>

<p>Two techniques are used in the graph generation phase: a context-free grammar and a user-defined ruleset. We found grammars to be appropriate for “growing” the structure of the graphs, but they are ill-suited to capture the semantics of the graph. To account for the semantics, we used a ruleset to maintain both local and global information about rooms in the graph.</p>

<h3>4.2.1  Adding Public Rooms</h3>

<p>The graph generation phase begins by determining the structure of the public rooms. The front door of the house is added first and production progresses using the context-free grammar according to the ruleset in ***FIGURE***. This step is solely responsible for structure, not semantics. Thus, the rooms added are not yet a specific type of room.</p>

<h3>4.2.2  Specifying Public Rooms</h3>
<p>Step two assigns a type (living room, dining room, etc.) to each public room by using four characteristics for each type:
  <ul>
    <li>
      Must-attach room: A room that must be attached to that particular room. This captures the notion of rooms that always come in pairs, such as kitchens and breakfast rooms.
    </li>
    <li>
      Potentially attaching rooms: A list of all the room types which may attach to the particular room, such as a bathroom potentially attaches to a den.
    </li>
    <li>
      Minimum number: The minimum number of rooms of a given type that should be in any given house. Some rooms have a minimum of zero because they may not occur in a house, such as an office. However, other rooms such as a kitchen always occur at least once.
    </li>
    <li>
      Maximum number: The maximum number of rooms of a given type that should be in any given house. Few houses have more than two dining rooms, no matter how large the house is. This statistic allows the total number of rooms to be limited.
    </li>
  </ul>
</p>

<p>The use of these statistics allows the creation of more realistic spaces than using the grammar alone. Additionally, these statistics can easily be modified by a user who would like finer control over the types and connections of rooms in a house. However, in the absence of user specifications, the statistics system can still behave intelligently to mimic average American houses.</p>


<h3>4.2.3  Adding Private Rooms</h3>

<p>After steps one and two, the graph has a set of public rooms. Step three randomly places private rooms adjoining public rooms until the private space is filled. The private space is considered filled when the square footage allotted to private rooms has been exhausted. Private rooms should only be accessible by means of a public room. The private ruleset in ***FIGURE*** is used to determine what combinations of private rooms are added.</p>

<p>Some of some of the rules in ***FIGURE*** feature a private room on the right side of the production denoted by the label ‘Priv.’ These nodes function as hallways to private areas and are expanded later in the graph expansion phase.</p>

<h3>4.2.4  Adding Stick-on Rooms</h3>

<p>The final step in creating the graph consists of adding rooms that are well-suited to being “stuck on” at the last minute, for example closets and pantries. These rooms can be added quickly and without impacting any of the other rooms already in the graph. For example, a pantry can be added to a kitchen without having to change other rooms. The statistics system also aids in this step to ensure logical connections.</p>

<h2>4.3  Graph Expansion</h2>

<p>At the beginning of this step, the types of rooms and the connections between them have been completely determined. However, the rooms are not located in absolute space. The placement phase distributes the rooms over the footprint. This placement process treats the graph as a tree with its root at the room that adjoins the front door. From that root, the root’s child nodes are then evenly distributed beneath the root with each child spread an equal distance from other children and an equal distance from the root. The process is then repeated for each of the children nodes.</p>

<h3>4.3.1  Complications</h3>

<p>The placement algorithm assumes that the graph will be mostly tree-like. Truthfully, it is not always a tree. Occasionally, there are connections between nodes on the same level. This is usually not a problem in the case of private rooms because the two rooms will most likely end up adjacent and a private room will rarely have any child nodes, unless they are a bedroom with a bathroom. However, if a public room has a connection to another room on the same (or higher) level, it can cause problems for the placement algorithm. To circumvent this problem, a cycle-detection algorithm is used and branches with cycles are relocated adjacent to one another. See ***FIGURE*** for an example of this.</p>

<h3>4.3.2  Expanding Rooms</h3>

<p>Rooms are expanded to their proper size relative to one another using a Monte Carlo method to choose which room to grow or shrink next. Every room in the graph exerts an outward “pressure” proportionate to the size the room should be relative to other rooms. Walls that are shared between rooms have pressure on them from both sides.</p>

<p>The four walls of the room are examined in turn. The decision of whether to grow or shrink a room by moving a wall is based on the difference between the pressure inside the room pushing out and the sum of the pressures pushing in on that wall from adjacent rooms. If the pressure from the inside is greater than the sum of the pressures from the outside, the room will expand by moving the wall under consideration a fraction of the footprint. If the pressure from outside is greater than that from inside, no expansion of that room takes place.</p>

<p>Either of two events can cause a room expansion step to fail:

  <ul>
    <li>The expansion causes a break in connectivity between rooms.</li>
    <li>The expansion causes the room to violate its aspect ratio by more than an acceptable tolerance.</li>
  </ul>
</p>

<h2>4.4  Results</h2>

<p>We implemented our algorithm in Java 1.5, executing the timing trials on a PowerMac G5 Dual 2.0GHz with 1GB of RAM. The application was single-threaded, and so did not use the second processor. Houses in the test runs had between twelve and eighteen rooms, with an average of fifteen. We used 300 iterations of the room expansion phase, observing that for fifteen rooms the expansion step hit equilibrium at about 250 iterations. The timing trial also generated the geometry for each house through the creation of an object file (OBJ format). The algorithm exhibits run time suitable for real-time applications. See ***FIGURE*** for a sample run of between 1,000 and 50,000 houses.</p>